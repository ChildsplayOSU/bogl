-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/Spiel-Lang#readme</a>
@package Spiel-Lang
@version 0.1.0.6


-- | Based on
--   @<a>https://stackoverflow.com/questions/41399055/haskell-yesod-cors-problems-with-browsers-options-requests-when-doing-post-req</a>
--   Enables CORS requests to be made to this server by accepting all
--   origins
module API.CORSMiddleware

-- | <tt>x-csrf-token</tt> allowance. The following header will be set:
--   <tt>Access-Control-Allow-Headers: x-csrf-token</tt>.
allowCsrf :: Middleware

-- | CORS middleware configured with <a>appCorsResourcePolicy</a>.
corsified :: Middleware

-- | Cors resource policy to be used with <a>corsified</a> middleware.
--   
--   This policy will set the following:
--   
--   <ul>
--   <li>RequestHeaders: <tt>Content-Type</tt></li>
--   <li>MethodsAllowed: <tt>OPTIONS, GET, PUT, POST</tt></li>
--   </ul>
appCorsResourcePolicy :: CorsResourcePolicy


module Language.Types

-- | Board definition
data BoardDef
BoardDef :: (Int, Int) -> Xtype -> BoardDef

-- | size of the board
[size] :: BoardDef -> (Int, Int)

-- | types of pieces that can be on the board
[piece] :: BoardDef -> Xtype

-- | Input definition
data InputDef
InputDef :: Xtype -> InputDef

-- | Type of input, Player inputs must be an accepted type
[inputType] :: InputDef -> Xtype

-- | Atomic types
data Btype

-- | Boolean
Booltype :: Btype

-- | Int
Itype :: Btype

-- | this is the type all symbols live in
AnySymbol :: Btype

-- | The input type specified at the top of the program
Input :: Btype

-- | A game board
Board :: Btype

-- | Really this is bottom FIXME
Top :: Btype

-- | Not definable by a user (only occurs when typechecking)
Undef :: Btype

-- | Xtypes are sum types (or tuples of sum types) but restricted by the
--   semantics to only contain Symbols after the atomic type. Note: ttypes
--   are subsumed by xtypes in our implementation
data Xtype
X :: Btype -> Set String -> Xtype
Tup :: [Xtype] -> Xtype
Hole :: String -> Xtype

-- | A function type can be from a plain type to a plain type (no curried
--   functions)
data Ftype
Ft :: Xtype -> Xtype -> Ftype

-- | A type is either a plain type or a function.
data Type
Plain :: Xtype -> Type
Function :: Ftype -> Type

-- | Nest a Btype as an Xtype
bnestx :: Btype -> Xtype

-- | Xtype smart constructor for Booltype
boolxt :: Xtype

-- | Xtype smart constructor for Itype
intxt :: Xtype

-- | Type smart constructor for Board
boardt :: Type

-- | Xtype smart constructor for Board
boardxt :: Xtype

-- | Nest a Btype as a Type
p :: Btype -> Type
instance GHC.Generics.Generic Language.Types.Type
instance GHC.Classes.Eq Language.Types.Type
instance GHC.Generics.Generic Language.Types.Ftype
instance GHC.Classes.Eq Language.Types.Ftype
instance GHC.Generics.Generic Language.Types.BoardDef
instance GHC.Generics.Generic Language.Types.InputDef
instance GHC.Classes.Eq Language.Types.Xtype
instance GHC.Generics.Generic Language.Types.Xtype
instance GHC.Classes.Eq Language.Types.Btype
instance GHC.Generics.Generic Language.Types.Btype
instance GHC.Classes.Ord Language.Types.Type
instance GHC.Show.Show Language.Types.Type
instance Data.Aeson.Types.ToJSON.ToJSON Language.Types.Type
instance GHC.Classes.Ord Language.Types.Ftype
instance GHC.Show.Show Language.Types.Ftype
instance Data.Aeson.Types.ToJSON.ToJSON Language.Types.Ftype
instance GHC.Show.Show Language.Types.BoardDef
instance GHC.Show.Show Language.Types.InputDef
instance GHC.Classes.Ord Language.Types.Xtype
instance GHC.Show.Show Language.Types.Xtype
instance Data.Aeson.Types.ToJSON.ToJSON Language.Types.Xtype
instance GHC.Classes.Ord Language.Types.Btype
instance GHC.Show.Show Language.Types.Btype
instance Data.Aeson.Types.ToJSON.ToJSON Language.Types.Btype


-- | Spiel language AST. This slightly deviates from the specified syntax
--   in spots.
module Language.Syntax

-- | Names of games, signatures, etc.
type Name = String

-- | Game datatype
data Game a
Game :: Name -> BoardDef -> InputDef -> [ValDef a] -> Game a

-- | The name of the game
[name] :: Game a -> Name

-- | Size and type of the board
[board] :: Game a -> BoardDef

-- | Type of input
[input] :: Game a -> InputDef

-- | List of value definitions
[defns] :: Game a -> [ValDef a]

-- | Signatures are a product of name and type.
data Signature
Sig :: Name -> Type -> Signature

-- | Parameters are lists of <a>Name</a>
data Parlist
Pars :: [Name] -> Parlist

-- | Top level values are signatures paired with either an ordinary
--   Equation or a list of Board Equations
data ValDef a

-- | Regular Value
Val :: Signature -> Equation a -> a -> ValDef a

-- | Board value
BVal :: Signature -> [BoardEq a] -> a -> ValDef a

-- | Equations
data Equation a

-- | Value equations (a mapping from <a>Name</a> to <a>Expr</a>)
Veq :: Name -> Expr a -> Equation a

-- | Function equations
Feq :: Name -> Parlist -> Expr a -> Equation a

-- | Board equations are used to set positions on the board to an
--   expression
data BoardEq a
PosDef :: Name -> Pos -> Pos -> Expr a -> BoardEq a
[boardEqName] :: BoardEq a -> Name
[xpos] :: BoardEq a -> Pos
[ypos] :: BoardEq a -> Pos
[boardExpr] :: BoardEq a -> Expr a

-- | Types of individual positions for the x and y in a board equation
data Pos

-- | Singular index as
Index :: Int -> Pos

-- | All indices with a given name
ForAll :: Name -> Pos

-- | Expressions
data Expr a

-- | Integer
I :: Int -> Expr a

-- | Symbol
S :: Name -> Expr a

-- | Boolean
B :: Bool -> Expr a

-- | Reference to a variable
Ref :: Name -> Expr a

-- | Tuple of <a>Expr</a>
Tuple :: [Expr a] -> Expr a

-- | Function application with argument tuple
App :: Name -> Expr a -> Expr a

-- | Binary operation
Binop :: Op -> Expr a -> Expr a -> Expr a

-- | Let binding
Let :: Name -> Expr a -> Expr a -> Expr a

-- | While loop
While :: Expr a -> Expr a -> [Name] -> Expr a -> Expr a

-- | Conditional
If :: Expr a -> Expr a -> Expr a -> Expr a

-- | Parameterized by the type of an annotation
Annotation :: a -> Expr a -> Expr a

-- | Type hole
HE :: Name -> Expr a

-- | Binary operations
data Op

-- | Addition (+)
Plus :: Op

-- | Subtraction (-)
Minus :: Op

-- | Multiplication (*)
Times :: Op

-- | Division (/)
Div :: Op

-- | Modulus (%)
Mod :: Op

-- | Less than comparison (&lt;)
Less :: Op

-- | Less than equal to comparison (&lt;=)
Leq :: Op

-- | Equivalent comparison (==)
Equiv :: Op

-- | Not equivalent comparison (/=)
NotEquiv :: Op

-- | Greater than equal to comparison (&gt;=)
Geq :: Op

-- | Greater than comparison (&gt;)
Greater :: Op

-- | Gets contents from a position on a board (!)
Get :: Op

-- | Check if a binary operator is arithmetic
arithmetic :: Op -> Bool

-- | Check if a binary operator is relational (excluding == and /=)
relational :: Op -> Bool

-- | Check if a binary operator is == or /=
equiv :: Op -> Bool

-- | Deannotate an expression
deAnnotate :: Expr a -> Expr a

-- | Clear the annotation from an expression
clearAnn :: Expr a -> Expr ()

-- | Get the identifier from a ValDef
ident :: ValDef a -> Name
instance GHC.Generics.Generic (Language.Syntax.Game a)
instance GHC.Generics.Generic (Language.Syntax.ValDef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Syntax.ValDef a)
instance GHC.Generics.Generic (Language.Syntax.Equation a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Syntax.Equation a)
instance GHC.Generics.Generic (Language.Syntax.BoardEq a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Syntax.BoardEq a)
instance GHC.Generics.Generic (Language.Syntax.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Syntax.Expr a)
instance GHC.Generics.Generic Language.Syntax.Op
instance GHC.Classes.Eq Language.Syntax.Op
instance GHC.Generics.Generic Language.Syntax.Pos
instance GHC.Classes.Eq Language.Syntax.Pos
instance GHC.Generics.Generic Language.Syntax.Parlist
instance GHC.Classes.Eq Language.Syntax.Parlist
instance GHC.Classes.Eq Language.Syntax.Signature
instance GHC.Show.Show (Language.Syntax.Game a)
instance GHC.Base.Functor Language.Syntax.ValDef
instance GHC.Show.Show (Language.Syntax.ValDef a)
instance GHC.Base.Functor Language.Syntax.Equation
instance GHC.Show.Show (Language.Syntax.Equation a)
instance GHC.Base.Functor Language.Syntax.BoardEq
instance GHC.Show.Show (Language.Syntax.BoardEq a)
instance GHC.Base.Functor Language.Syntax.Expr
instance GHC.Show.Show (Language.Syntax.Expr a)
instance GHC.Show.Show Language.Syntax.Op
instance GHC.Classes.Ord Language.Syntax.Pos
instance GHC.Show.Show Language.Syntax.Pos
instance GHC.Show.Show Language.Syntax.Parlist
instance GHC.Show.Show Language.Syntax.Signature


-- | Holds some functions for reporting parser errors
module Parser.Error

-- | Double quotes a string
quote :: String -> String

-- | Uses a list of strings to produce a single string of the double quoted
--   strings
quoteMany :: [String] -> String

-- | Constructs an error message indicating which params were repeated in
--   what context
errRepeatParam :: [String] -> String -> String


module Runtime.Values

-- | Representation of a Board in BoGL, composed of an NxM array of
--   <a>Val</a>
type Board = Array (Int, Int) Val

-- | Evaluation environment
type EvalEnv = [(Name, Val)]

-- | Runtime values that can be encountered
data Val

-- | Integer value
Vi :: Int -> Val

-- | Boolean value
Vb :: Bool -> Val

-- | Board value (displayed to user)
Vboard :: Board -> Val

-- | Tuple value
Vt :: [Val] -> Val

-- | Symbol value
Vs :: Name -> Val

-- | Function value (annotations discarded)
Vf :: [Name] -> EvalEnv -> Expr () -> Val

-- | Deannotated pending value allows for <a>input</a> in Val Eqs
Pv :: EvalEnv -> Expr () -> Val

-- | Runtime error (caught by typechecker)
Err :: String -> Val

-- | This needs an input.
Deferred :: Val

-- | Encodes a 1D board array as a string
encode1DArray :: [((Int, Int), Val)] -> String

-- | Encodes a 2D board array as a string
encode2DArray :: [[((Int, Int), Val)]] -> String

-- | Convert an array to a grid
toGrid :: (Ix c, Ix b1) => Array (c, b1) b2 -> [[((c, b1), b2)]]
instance GHC.Generics.Generic Runtime.Values.Val
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Values.Val
instance GHC.Classes.Eq Runtime.Values.Val
instance GHC.Show.Show Runtime.Values.Val


-- | Evaluation Monad
module Runtime.Monad

-- | Eval Monad transformer
type Eval a = StateT Buffer (ExceptT Exception (ReaderT Env (Identity))) a

-- | Call-by-value semantics
data Env
Env :: EvalEnv -> (Int, Int) -> Env
[evalEnv] :: Env -> EvalEnv
[boardSize] :: Env -> (Int, Int)

-- | Uses the StateT monad to request the typed board dimensions in the
--   runtime environment
getBounds :: Eval (Int, Int)

-- | Uses the StateT monad to get the evaluation environment in the runtime
--   environment
getEnv :: Eval EvalEnv

-- | Produces an empty environment for testing, and for starting
--   evaluations
emptyEnv :: (Int, Int) -> Env

-- | Modifies the evaluation environment, producing a new environment
modifyEval :: (EvalEnv -> EvalEnv) -> Env -> Env

-- | Input buffer and display buffer. The display buffer stores all boards
--   which are to be printed on the front end after a board is updated
--   Additionally counts the number of evaluation iterations, stopping
--   after a fixed amount with a 'Error $ "Stack Overflow!"'
type Buffer = ([Val], [Val], Int)

-- | Exceptions
data Exception

-- | Ran out of input and here's the buffered display boards
NeedInput :: [Val] -> Exception

-- | Encountered a runtime error
Error :: String -> Exception

-- | Take an expressions, and before evaluating it checks &amp; updates
--   evaluation iterations If the count is less than the limit, continue
--   evaluating, otherwise return an error instead of evluating further.
--   Prevents infinite loops via recursion, while, or self referencing
--   value equations, among other things
evalWithLimit :: Eval Val -> Eval Val

-- | Evaluation occurs in the Identity monad with these side effects:
--   ReaderT: Evaluation enviroment, board size and piece type, and input
--   type StateT: Input buffer, used for reading input
--   
--   Evaluate in the environment given, with a buffer.
runEval :: Env -> Buffer -> Eval a -> Either Exception a

-- | Evaluate with an extended scope
extScope :: EvalEnv -> Eval a -> Eval a

-- | Lookup a name in the environment FIXME
lookupName :: Name -> Eval (Maybe Val)

-- | Ask for input, displaying a value to the user
waitForInput :: [Val] -> Eval a

-- | Converts a string into an evaluation error
err :: String -> Eval a

-- | Read input
readTape :: Eval Val

-- | Helper function to get the Bool out of a value. This is a partial
--   function.
unpackBool :: Val -> Maybe Bool
instance GHC.Show.Show Runtime.Monad.Exception
instance GHC.Classes.Eq Runtime.Monad.Exception
instance GHC.Show.Show Runtime.Monad.Env


module Runtime.Builtins

-- | Produces a Tuple type wrapping a single Xtype
single :: Xtype -> Xtype

-- | List of builtin function signatures
builtinT :: Xtype -> Xtype -> [(String, Type)]

-- | places a piece on a board and also adds this new board to the display
--   buffer. We only want the latest version of each unique board, so
--   filter out its predecessor.
place :: [Val] -> Eval Val

-- | Verifies the parameters are of the expected number &amp; type from
--   their respective lambdas A final case reports a Runtime error in case
--   anything slips by, which indicates that the number and/or type of
--   parameters didn't match what was expected for that builtin Note: This
--   prevents a crash and gives somewhat better feedback to users, but this
--   should not normally be reachable if the typechecker verifies the
--   expressions correctly in advance
builtinsChecker :: [Char] -> [Val] -> Eval Val

-- | List of builtin functions, with definitions for evaluation
builtins :: [(Name, [Val] -> Eval Val)]

-- | Builtin references, just input for now
builtinRefs :: [(Name, Eval Val)]

-- | the count of adjacent cells in four directions (above, diagonal <tt>
--   10:30, left, diagonal </tt> 7:30)
type Count = (Int, Int, Int, Int)

-- | Map of the count
type CountMap = Map (Int, Int) Count

-- | A safe map lookup function which returns a default value for keys not
--   in the map
peek :: (Int, Int) -> CountMap -> Count

-- | Adds a cell into the count map
addCell :: (Int, Int) -> CountMap -> CountMap

-- | Checks a cell in the count map
checkCell :: Val -> ((Int, Int), Val) -> CountMap -> CountMap

-- | Scans cells downwards by column (the order given by (assocs b) with
--   (x,y) coords) each cell's count is the increment of the counts of the
--   four cells before it
checkCells :: Board -> Val -> [Int]

-- | Counts cols, rows, and diagonals in a board
countCol :: Board -> Val -> Int

-- | Counts cols, rows, and diagonals in a board
countRow :: Board -> Val -> Int

-- | Counts cols, rows, and diagonals in a board
countDiag :: Board -> Val -> Int

-- | checks whether a board has i cells containing v in a row
inARow :: Board -> Val -> Int -> Bool


module Runtime.Eval

-- | Produce all of the bindings from a list of value definitions. This is
--   done sequentially. Errors are reported as they're found.
bindings :: (Int, Int) -> [ValDef a] -> Writer [Exception] Env

-- | Partial application of of args to <a>bindings</a>, allows passing in
--   just a list of ValDefs
bindings_ :: (Int, Int) -> [ValDef a] -> Env

-- | Binds a value equation
--   
--   Binds a ValDef to a name and a Val in the Eval monad
bind :: ValDef a -> (Name, Eval Val)

-- | Updates a board
updateBoard :: Board -> (Int, Int) -> BoardEq a -> Val -> Board

-- | Check if a Pos matches a coordinate pair
posMatches :: Pos -> Pos -> (Int, Int) -> Bool

-- | Attempt to access a position on the board that may be invalid If the
--   position is invalid, return an Err value instead of causing an actual
--   array access error
tryUnsafeBoardAccess :: (Int, Int) -> Board -> Val

-- | Binary operation evaluation
evalBinOp :: Op -> Expr a -> Expr a -> Eval Val

-- | evaluates the == and /= operations
evalEq :: (Val -> Val -> Bool) -> Expr a -> Expr a -> Eval Val

-- | evaluates comparison operations for only Ints (except for == &amp; /=)
evalCompareOpInt :: (Int -> Int -> Bool) -> Expr a -> Expr a -> Eval Val

-- | evaluates numerical operations
evalNumOp :: String -> (Int -> Int -> Int) -> Expr a -> Expr a -> Eval Val

-- | Evaluates an expression at runtime, producing a Val in the Eval monad
eval :: Expr a -> Eval Val

-- | Runs an expression under a given environment and a given buffer,
--   producing a result of either a list of values and a buffer, or a list
--   of values and a single value
runWithBuffer :: Env -> Buffer -> Expr SourcePos -> Either ([Val], Buffer) ([Val], Val)


module Parser.Parser

-- | Parse a single line as an expression
parseLine :: String -> Either ParseError (Expr SourcePos)

-- | Parse the prelude from text
parsePreludeFromText :: String -> Either ParseError ([Maybe (ValDef SourcePos)], ParState)

-- | Parse a game from text and the result of a previous parse (e.g. the
--   prelude) Such as in the case of the function above
--   <a>parsePreludeFromtext</a>
parseGameFromText :: String -> ([Maybe (ValDef SourcePos)], ParState) -> ParseResult

-- | Parse a game from a string
parseGameFile :: String -> IO ParseResult

-- | Parse a prelude and game from text directly, without a file
parsePreludeAndGameText :: String -> String -> IO ParseResult

-- | Parser for the <a>Expr</a> datatype
expr :: Parser (Expr SourcePos)

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: () => Either a b -> Bool

-- | Uses the parser p to parse all input, throws an error if anything is
--   left over
parseAll :: Parser a -> String -> String -> Either ParseError a

-- | Value definitions
valdef :: Parser (ValDef SourcePos)

-- | Extended types: types after the first are restricted to symbols
xtype :: Parser Xtype

-- | Board equations
boardeqn :: String -> Parser (BoardEq SourcePos)

-- | Equations
equation :: Parser (Equation SourcePos)

-- | Parse a typesyn or a valdef
decl :: Parser (Maybe (ValDef SourcePos))

-- | Game definition
parseGame :: [ValDef SourcePos] -> Parser (Game SourcePos)

-- | Type Synonym Definition, but returns nothing
typesyn :: Parser ()

-- | Parser type
type Parser = Parsec String (ParState)


module Typechecker.Monad

-- | Types in the environment
type TypeEnv = [(Name, Type)]

-- | Typechecker environment
data Env
Env :: TypeEnv -> Xtype -> Xtype -> (Int, Int) -> Env
[types] :: Env -> TypeEnv
[input] :: Env -> Xtype
[piece] :: Env -> Xtype
[size] :: Env -> (Int, Int)

-- | Initial empty environment
initEnv :: Xtype -> Xtype -> (Int, Int) -> Env

-- | An example environment for interal use (e.g. testing, ghci)
exampleEnv :: Env

-- | Typechecker state
data Stat
Stat :: TypeEnv -> Maybe (Expr SourcePos) -> SourcePos -> Stat
[holes] :: Stat -> TypeEnv
[source] :: Stat -> Maybe (Expr SourcePos)
[pos] :: Stat -> SourcePos

-- | Typechecking monad
type Typechecked a = (StateT Stat (ReaderT Env (ExceptT TypeError Identity))) a

-- | Run a computation inside of the typechecking monad
typecheck :: Env -> Typechecked a -> Either TypeError (a, Stat)

-- | Typecheck type holes
typeHoles :: Env -> Typechecked a -> Either TypeError (a, TypeEnv)

-- | Add some types to the environment
extendEnv :: Env -> (Name, Type) -> Env

-- | Get the type environment
getEnv :: Typechecked TypeEnv

-- | Get the input type
getInput :: Typechecked Xtype

-- | Get the piece type
getPiece :: Typechecked Xtype

-- | Get the board size
getSize :: Typechecked (Int, Int)

-- | Check whether (x,y) is in the bounds of the board
inBounds :: (Int, Int) -> Typechecked Bool

-- | Extend the environment
localEnv :: ([(Name, Type)] -> [(Name, Type)]) -> Typechecked a -> Typechecked a

-- | Get the current type holes
getHoles :: Typechecked TypeEnv

-- | Set the source line
setSrc :: Expr SourcePos -> Typechecked ()

-- | Set the position
setPos :: SourcePos -> Typechecked ()

-- | Get the position
getPos :: Typechecked SourcePos

-- | Get the source line
getSrc :: Typechecked (Expr SourcePos)

-- | Get a type from the environment
getType :: Name -> Typechecked Type

-- | add a type hole
addHole :: (Name, Type) -> Typechecked ()

-- | Attempt to unify two types
unify :: Xtype -> Xtype -> Typechecked Xtype

-- | Returns a typechecked base type
t :: Btype -> Typechecked Xtype

-- | Encoding the different type errors as types should let us do
--   interesting things with them
data TypeError

-- | Couldn't match two types in an expression
Mismatch :: Type -> Type -> Expr SourcePos -> SourcePos -> TypeError
[t1] :: TypeError -> Type
[t2] :: TypeError -> Type
[srcPos2] :: TypeError -> Expr SourcePos
[srcPos] :: TypeError -> SourcePos

-- | Name isn't (yet) bound in the enviroment
NotBound :: Name -> SourcePos -> TypeError
[name] :: TypeError -> Name
[srcPos] :: TypeError -> SourcePos

-- | couldn't match the type of an equation with its signature
SigMismatch :: Name -> Type -> Type -> SourcePos -> TypeError
[name] :: TypeError -> Name
[sigType] :: TypeError -> Type
[actualType] :: TypeError -> Type
[srcPos] :: TypeError -> SourcePos

-- | Errors that "shouldn't happen"
Unknown :: String -> SourcePos -> TypeError
[msg] :: TypeError -> String
[srcPos] :: TypeError -> SourcePos

-- | Can't perform a primitive operation
BadOp :: Op -> Type -> Type -> Expr SourcePos -> SourcePos -> TypeError
[op] :: TypeError -> Op
[t1] :: TypeError -> Type
[t2] :: TypeError -> Type
[srcPos2] :: TypeError -> Expr SourcePos
[srcPos] :: TypeError -> SourcePos
OutOfBounds :: Pos -> Pos -> SourcePos -> TypeError
[xpos] :: TypeError -> Pos
[ypos] :: TypeError -> Pos
[srcPos] :: TypeError -> SourcePos

-- | An attempt to apply a non-function expr as if it were a function
BadApp :: Name -> Expr SourcePos -> SourcePos -> TypeError
[name] :: TypeError -> Name
[arg] :: TypeError -> Expr SourcePos
[srcPos] :: TypeError -> SourcePos

-- | An attempt to dereference a function
Dereff :: Name -> Type -> SourcePos -> TypeError
[name] :: TypeError -> Name
[typ] :: TypeError -> Type
[srcPos] :: TypeError -> SourcePos
Uninitialized :: Name -> SourcePos -> TypeError
[name] :: TypeError -> Name
[srcPos] :: TypeError -> SourcePos

-- | Type mismatch error
mismatch :: Type -> Type -> Typechecked a

-- | Not bound type error
notbound :: Name -> Typechecked a

-- | Signature mismatch type error
sigmismatch :: Name -> Type -> Type -> Typechecked a

-- | Unknown type error
unknown :: String -> Typechecked a

-- | Bad Op type error
badop :: Op -> Type -> Type -> Typechecked a

-- | Out of Bounds type error
outofbounds :: Pos -> Pos -> Typechecked a

-- | Uninitialized board type error
uninitialized :: Name -> Typechecked a

-- | Bad function application type error
badapp :: Name -> Expr SourcePos -> Typechecked a

-- | Cannot dereference function type error
dereff :: Name -> Type -> Typechecked a

-- | Retrieve the extensions from an Xtype
extensions :: Xtype -> Typechecked (Set Name)

-- | Produce a human readable error string from a source position
errString :: SourcePos -> String
instance GHC.Classes.Eq Typechecker.Monad.TypeError
instance Data.Aeson.Types.ToJSON.ToJSON Typechecker.Monad.TypeError
instance GHC.Show.Show Typechecker.Monad.TypeError


module API.JSONData

-- | Representation of a request to read a BoGL file
data SpielRead
SpielRead :: String -> SpielRead
[path] :: SpielRead -> String

-- | Representation of a request to share a prelude &amp; gamefile
data SpielShare
SpielShare :: String -> String -> SpielShare
[preludeContent] :: SpielShare -> String
[gameContent] :: SpielShare -> String

-- | Representation of a file that will be saved by the user
data SpielFile
SpielFile :: String -> String -> SpielFile
[fileName] :: SpielFile -> String
[content] :: SpielFile -> String

-- | Representation of input to the repl, from the user
data SpielCommand
SpielCommand :: String -> String -> String -> [Val] -> SpielCommand
[prelude] :: SpielCommand -> String
[file] :: SpielCommand -> String
[input] :: SpielCommand -> String
[buffer] :: SpielCommand -> [Val]

-- | Error message
type Message = String

-- | Error line number
type LineNum = Int

-- | Error column number
type ColNum = Int

-- | Error file name
type FileName = String

-- | A buffer of boards which should be printed with the value of executing
--   the expression
type BufferedBoards = [Val]

-- | An execution value
type ExecutionValue = Val

-- | Represents possible response categories from the server These are then
--   parsed accordingly on the front-end
data SpielResponse

-- | represents a prompt for input and buffered boards
SpielPrompt :: [Val] -> SpielResponse

-- | represents a successful operation
SpielSuccess :: String -> SpielResponse

-- | represents a successful load 1st prelude, 2nd gamefile
SpielLoadResult :: String -> String -> SpielResponse

-- | represents a win/lose result
SpielGameResult :: String -> SpielResponse

-- | represents a type error
SpielTypeError :: TypeError -> SpielResponse

-- | represents a parse error
SpielParseError :: LineNum -> ColNum -> FileName -> Message -> SpielResponse

-- | represents a runtime error in spiel
SpielValue :: BufferedBoards -> ExecutionValue -> SpielResponse

-- | represents a typed hole that can be filled
SpielTypeHole :: LineNum -> ColNum -> Xtype -> SpielResponse

-- | fallback standard error, something went wrong in spiel
SpielError :: String -> SpielResponse

-- | generic runtime error
SpielRuntimeError :: String -> SpielResponse

-- | List of typechecked types
SpielTypes :: [(String, Type)] -> SpielResponse

-- | String
Log :: String -> SpielResponse

-- | List of spiel responses
type SpielResponses = [SpielResponse]
instance GHC.Generics.Generic API.JSONData.SpielResponse
instance GHC.Classes.Eq API.JSONData.SpielResponse
instance GHC.Generics.Generic API.JSONData.SpielCommand
instance GHC.Show.Show API.JSONData.SpielCommand
instance GHC.Classes.Eq API.JSONData.SpielCommand
instance GHC.Generics.Generic API.JSONData.SpielFile
instance GHC.Show.Show API.JSONData.SpielFile
instance GHC.Classes.Eq API.JSONData.SpielFile
instance GHC.Generics.Generic API.JSONData.SpielShare
instance GHC.Show.Show API.JSONData.SpielShare
instance GHC.Classes.Eq API.JSONData.SpielShare
instance GHC.Generics.Generic API.JSONData.SpielRead
instance GHC.Show.Show API.JSONData.SpielRead
instance GHC.Classes.Eq API.JSONData.SpielRead
instance Data.Aeson.Types.ToJSON.ToJSON API.JSONData.SpielResponse
instance GHC.Show.Show API.JSONData.SpielResponse
instance Data.Aeson.Types.ToJSON.ToJSON API.JSONData.SpielCommand
instance Data.Aeson.Types.FromJSON.FromJSON API.JSONData.SpielCommand
instance Data.Aeson.Types.ToJSON.ToJSON API.JSONData.SpielFile
instance Data.Aeson.Types.FromJSON.FromJSON API.JSONData.SpielFile
instance Data.Aeson.Types.ToJSON.ToJSON API.JSONData.SpielShare
instance Data.Aeson.Types.FromJSON.FromJSON API.JSONData.SpielShare
instance Data.Aeson.Types.FromJSON.FromJSON API.JSONData.SpielRead
instance Data.Aeson.Types.FromJSON.FromJSON Runtime.Values.Val


module API.Test

-- | Returns a test reponse to the GET test endpoint, to ensure this is
--   running
handleTest :: SpielResponses


module API.ShareFile

-- | Handles sharing files to the server space
handleShareFile :: SpielShare -> Handler SpielResponses

-- | Generates a unique filename for the shared directory
genUniqueFilename :: IO String


module API.ReadFile

-- | Handles reading a file and returning it's contents to the requester
handleReadFile :: SpielRead -> Handler SpielFile


module API.Load

-- | Handles reading the prelude and file
handleLoad :: SpielRead -> Handler SpielResponse


module Typechecker.Typechecker

-- | Run the typechecker on an <a>Expr</a> and report any errors to the
--   console.
tcexpr :: Env -> Expr SourcePos -> Either TypeError (Xtype, TypeEnv)

-- | Produce the environment
environment :: BoardDef -> InputDef -> [ValDef SourcePos] -> Env

-- | Runs the typechecker on a board def, input def, list of valdefs, and
--   produces results of errors or successfully typechecked names recursion
--   is not allowed by this.
runTypeCheck :: BoardDef -> InputDef -> [ValDef SourcePos] -> Writer [Either (ValDef SourcePos, TypeError) (Name, Type)] Env

-- | Typecheck a game and produce a typechecker result
tc :: Game SourcePos -> TcResult

-- | Produce a string of types in the environment
printT :: (Xtype, TypeEnv) -> String

-- | Typechecker Result
data TcResult
Tc :: Bool -> Env -> [(ValDef SourcePos, TypeError)] -> [(Name, Type)] -> TcResult

-- | Success result
[success] :: TcResult -> Bool

-- | Env associated with the result
[e] :: TcResult -> Env

-- | Typechecker errors
[errors] :: TcResult -> [(ValDef SourcePos, TypeError)]

-- | List of (name,type) pairs
[rtypes] :: TcResult -> [(Name, Type)]

-- | Produces an error corresponding to a typechecker error
showTCError :: (ValDef SourcePos, TypeError) -> String


-- | Holds utility run code for both <i>runCmds and </i>runCode. Holds the
--   routines for parsing and interpreting a BoGL Prelude and Game file.
module API.Run

-- | Runs BoGL code from raw text with the given commands utilizes
--   parsePreludeAndGameText to parse the code directly, without reading it
--   from a file first
_runCodeWithCommands :: SpielCommand -> IO SpielResponses


module API.RunCode

-- | Runs literal code, lifting it into Handler Runs the contents of the
--   prelude and gamefile without writing them out into files Once these
--   both succeed, the new temporary files are parsed , and the response is
--   returned
handleRunCode :: SpielCommand -> Handler SpielResponses


-- | Handles starting up an instance of Servant Returns encoded board data
--   on request, and computes boards when input data is taken
module API.Server

-- | Starts the language server
startServer :: Int -> IO ()

-- | Prepares a server application
serverApp :: Application

-- | Type of the API (Headers '[Header "Access-Control-Allow-Origin"
--   String] SpielResponses)
type SpielApi = "share" :> ReqBody '[JSON] SpielShare :> Post '[JSON] SpielResponses :<|> "load" :> ReqBody '[JSON] SpielRead :> Post '[JSON] SpielResponse :<|> "runCode" :> ReqBody '[JSON] SpielCommand :> Post '[JSON] SpielResponses :<|> "read" :> ReqBody '[JSON] SpielRead :> Post '[JSON] SpielFile :<|> "test" :> Get '[JSON] SpielResponses
